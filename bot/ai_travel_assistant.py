import asyncio
import logging
import os
import re
import base64
import httpx

from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, WebAppInfo, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (ApplicationBuilder, CommandHandler, MessageHandler, CallbackContext, filters,
                          CallbackQueryHandler, ConversationHandler)
from telegram.constants import ChatAction, ParseMode
import requests

from openai_stuff.openai_stuff import OpenAIAssistant
from openai import OpenAI

TOKEN = ""
BOT_USERNAME = "ai_assist_travel_bot"

ASSISTANT_ID = "asst_iupcjGidXND8e9fKvg4WYudH"
OPENAI_API_KEY = os.environ['OPENAI_API_KEY']
ASSISTANT_GPT = OpenAIAssistant(OPENAI_API_KEY, ASSISTANT_ID)

OpenAI.api_key = OPENAI_API_KEY
client = OpenAI()

DATE, TIME, CONFIRM = range(3)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(format='%(asctime)s - %(levelname)s - %(funcName)s - %(message)s', level=logging.INFO)
# Configure the httpx logger to only output warnings or higher level messages
logging.getLogger("httpx").setLevel(logging.WARNING)


# Function to encode the image
def encode_image(image_path):
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')


async def get_balance(update: Update, context: CallbackContext) -> None:
    kb = [
        [InlineKeyboardButton("–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–≤–æ–π –∫—ç—à–±–µ–∫", web_app=WebAppInfo(url="https://gentle-piglet-legal.ngrok-free.app/view_my_chashback"))]
    ]
    reply_markup = InlineKeyboardMarkup(kb)
    await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç:", reply_markup=reply_markup)


async def shop(update: Update, context: CallbackContext) -> None:
    kb = [
        [InlineKeyboardButton("üõçÔ∏è –û—Ç–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–º–∞–≥–∞–∑–∏–Ω —Å —Ç–æ–≤–∞—Ä–∞–º–∏ –Ω–∞—à–∏—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤", web_app=WebAppInfo(url="https://travel.ucoz.ae/shop/telegram_shop"))]
    ]
    reply_markup = InlineKeyboardMarkup(kb)
    await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –º–∞–≥–∞–∑–∏–Ω:", reply_markup=reply_markup)

# –û—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é
async def start(update: Update, context: CallbackContext) -> None:
    chat_id = update.message.chat_id
    user = update.message.from_user
    tg_user_params = {
        'tg_id': user.id,
        'tg_username': user.username,
        'tg_first_name': user.first_name,
        'tg_last_name': user.last_name
    }
    user_type = None
    card_number = ''

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–µ—à–±–µ–∫–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    # cashback = get_user_cashback(tg_username)
    cashback = 3250
    # card_number = 1001
    response = requests.post("http://127.0.0.1:8000/register", json=tg_user_params)
    if response.status_code == 201:
        card_number = response.json()['card_number']
        user_type = response.json()['user_type']
        await update.message.reply_text(f'Welcome! Your discount card number is {card_number}.')
    elif response.status_code == 200:
        card_number = response.json()['card_number']
        user_type = response.json()['user_type']
        await update.message.reply_text(f'Welcome back! Your card number is: {card_number}')

    web_app_url = (f"https://gentle-piglet-legal.ngrok-free.app/view_my_chashback"
                   f"?tg_username={tg_user_params['tg_username']}&tg_first_name={tg_user_params['tg_first_name']}"
                   f"&tg_last_name={tg_user_params['tg_last_name']}&cashback={cashback}&card_number={card_number}")

    kb = [
        [KeyboardButton("üéß –ü–æ–º–æ—â—å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞")],
        [KeyboardButton("‚ÅâÔ∏è –û –Ω–∞—à–µ–º —Å–µ—Ä–≤–∏—Å–µ"), KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤")],
        [KeyboardButton("üçΩÔ∏è –ú–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")],
        [KeyboardButton("üí∏ –ú–æ–π –∫—ç—à–±–µ–∫", web_app=WebAppInfo(url=web_app_url)), KeyboardButton("üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —á–µ–∫")]
    ]
    reply_markup = ReplyKeyboardMarkup(kb, resize_keyboard=True)

    # # –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –ø—Ä–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º –≤—ã–∑–æ–≤–µ –∫–æ–º–∞–Ω–¥—ã /start
    await update.message.reply_text('–ü—Ä–∏–≤–µ—Ç! –Ø –∫–æ–Ω—Å—å–µ—Ä–∂-–±–æ—Ç –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–æ—Å—É–≥–∞')
    await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
    await asyncio.sleep(0.5)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –ø–µ—á–∞—Ç–∏
    await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ –Ω–∏–∂–µ:", reply_markup=reply_markup)


def clean_response(text):
    cleaned_text = re.sub(r'„Äê\d+:\d+‚Ä†*„Äë', '', text)
    return cleaned_text.strip()


async def handle_operator(update: Update, context: CallbackContext, user_input: str) -> str:
    chat_id = update.effective_chat.id
    tg_username = update.effective_user.username
    context_thread_id = context.user_data.get('thread')

    await context.bot.send_chat_action(chat_id=chat_id, action="typing")
    await asyncio.sleep(0.8)

    try:
        logging.info(f'QUESTION: tg_username: {tg_username} - {user_input}')

        if context_thread_id:
            response, _ = ASSISTANT_GPT.fetch_formatted_response(user_input=user_input, thread_id=context_thread_id)
        else:
            response, thread_id = ASSISTANT_GPT.fetch_formatted_response(user_input=user_input)
            context.user_data['thread'] = thread_id

        if not response:
            raise ValueError("Received empty response from ChatGPT")

        cleaned_response = clean_response(response)
        logging.info(f'ANSWER: tg_username: {tg_username} - {cleaned_response}')
        return cleaned_response
    except Exception as e:
        logging.error("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: " + str(e))
        return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."


async def recognize_total_amount(image_path):
    base64_image = encode_image(image_path)

    try:
        with open(image_path, "rb") as image_file:
            response = client.chat.completions.create(
                model="gpt-4-turbo",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": "–ù–∞–π–¥–∏ –∏—Ç–æ–≥–æ–≤—É—é —Å—É–º–º—É —á–µ–∫–∞ –∏ –≤—ã–≤–µ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–æ–ª—å–∫–æ —ç—Ç—É —Å—É–º–º—É. "
                                                     "–ù–∏–∫–∞–∫–∏–µ –¥—Ä—É–≥–∏–µ —Å–ª–æ–≤–∞ –Ω–µ –≤—ã–≤–æ–¥–∏"},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                },
                            },
                        ],
                    }
                ],
                max_tokens=10
            )
        return response.choices[0].message.content
    except httpx.RequestError as e:
        logging.error(f"An error occurred while requesting: {e}")
        raise
    except httpx.HTTPStatusError as e:
        logging.error(f"Error response {e.response.status_code} while requesting {e.request.url}")
        raise
    except Exception as e:
        logging.error(f"Error while the calling the transcribe_audio_with_openai {str(e)}")
        raise


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
async def handle_photo(update: Update, context: CallbackContext) -> None:
    photo_file = await update.message.photo[-1].get_file()
    file_path = os.path.join("/tmp", f"{photo_file.file_id}.jpg")
    await photo_file.download_to_drive(file_path)
    await update.message.reply_text("–§–æ—Ç–æ–≥—Ä–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è...")

    # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
    total_amount = await recognize_total_amount(file_path)

    if total_amount:
        await update.message.reply_text(f"–°—É–º–º–∞ –Ω–∞ —á–µ–∫–µ: {total_amount} —Ä—É–±.")
    else:
        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Å—É–º–º—É –Ω–∞ —á–µ–∫–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")


# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def handle_message(update: Update, context: CallbackContext) -> None:
    user_message = update.message.text
    chat_id = update.message.chat_id

    if user_message == "üéß –ü–æ–º–æ—â—å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞":
        await update.message.reply_text("–°–≤—è–∑—ã–≤–∞—é –≤–∞—Å —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º...")
        await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
        await asyncio.sleep(0.3)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –ø–µ—á–∞—Ç–∏
        await update.message.reply_text("–û–ø–µ—Ä–∞—Ç–æ—Ä –Ω–∞ —Å–≤—è–∑–∏, –≤–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å")
        context.user_data['awaiting_response'] = True  # –§–ª–∞–≥ –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    elif user_message in ["‚ÅâÔ∏è –û –Ω–∞—à–µ–º —Å–µ—Ä–≤–∏—Å–µ", "üìã –°–ø–∏—Å–æ–∫ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤", "üçΩÔ∏è –ú–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è", "üí∏ –ú–æ–π –∫—ç—à–±–µ–∫"]:
        context.user_data['awaiting_response'] = False  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
        await handle_predefined_questions(update, context, user_message)
    elif user_message == "üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —á–µ–∫":
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞.")
    else:
        if context.user_data.get('awaiting_response'):
            response = await handle_operator(update, context, user_message)
            await update.message.reply_text(response)
        else:
            await update.message.reply_text("–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ –ø–æ–Ω—è–ª –≤–∞—à –∑–∞–ø—Ä–æ—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –º–µ–Ω—é.")


async def handle_query(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    text = query.data

    logging.info(f"Received callback query: {text}")

    if text in ['Hotel', 'Restaurant', 'Yacht', 'TourOperator']:
        logging.info(f"user {update.effective_user.username} selected {text}")

        response = requests.get(f"http://127.0.0.1:8000/get_vendors?vendor_type={text}")
        if response.status_code == 200:
            vendors = response.json()
            context.user_data['vendors'] = vendors
            message, reply_markup = format_vendor_list_with_buttons(vendors)
            await query.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        else:
            logging.error(f"Failed to get vendors: {response.status_code}")
            await query.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –≤–µ–Ω–¥–æ—Ä–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    elif text.startswith('select_vendor_'):
        vendor_id = int(text.split('_')[2])
        logging.info(f"vendor {vendor_id}")

        response = requests.get(f"http://127.0.0.1:8000/get_services?vendor_id={vendor_id}")
        if response.status_code == 200:
            services = response.json()
            message, reply_markup = get_list_services(services)
            await query.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        else:
            logging.error(f"Failed to get services: {response.status_code}")
            await query.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —É—Å–ª—É–≥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

    elif text == "back_to_vendors":
        await get_vendors_type_list(update, context, True)
    else:
        logging.error(f"Unknown callback data {text}")
        await query.message.reply_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å.")

# Conversation handler states
async def book_service(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    text = query.data
    context.user_data['service_id'] = int(text.split('_')[2])

    logging.info(f"Entering book_service with callback query: {query.data}")
    await query.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∂–µ–ª–∞–µ–º—É—é –¥–∞—Ç—É –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (–≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD):")
    return DATE

async def received_date(update: Update, context: CallbackContext):
    logging.info(f"Entering received_date with message: {update.message.text}")
    context.user_data['booking_date'] = update.message.text
    await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∂–µ–ª–∞–µ–º–æ–µ –≤—Ä–µ–º—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (–≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM):")
    return TIME

async def received_time(update: Update, context: CallbackContext):
    logging.info(f"Entering received_time with message: {update.message.text}")
    context.user_data['booking_time'] = update.message.text
    booking_date = context.user_data['booking_date']
    booking_time = context.user_data['booking_time']

    keyboard = [
        [InlineKeyboardButton("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data='confirm')],
        [InlineKeyboardButton("–û—Ç–º–µ–Ω–∏—Ç—å", callback_data='cancel')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        f"–í—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ {booking_date} –≤ {booking_time}. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ.",
        reply_markup=reply_markup)
    return CONFIRM

async def confirm_booking(update: Update, context: CallbackContext):
    logging.info("Entering confirm_booking")
    query = update.callback_query
    await query.answer()
    booking_date = context.user_data['booking_date']
    booking_time = context.user_data['booking_time']
    tg_user_id = query.from_user.id

    booking_params = {
        'tg_id': tg_user_id,
        'service_id': context.user_data['service_id'],
        'booking_date_time': f"{booking_date} {booking_time}"
    }

    response = requests.post("http://127.0.0.1:8000/add_booking", json=booking_params)
    if response.status_code == 201:
        booking_id = response.json()['booking_id']
        context.user_data['booking_id'] = booking_id
        await notify_vendor(context)
        await query.edit_message_text(f"–í–∞—à–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ {booking_date} –≤ {booking_time} "
                                      f"–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–∞—Ä—Ç–Ω–µ—Ä—É –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
        return ConversationHandler.END
    else:
        logging.error(f"Error during the booking process! response.status_code: {response.status_code}")
        await query.edit_message_text(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∞—à–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é –ø–æ–∑–¥–Ω–µ–µ")


async def cancel_booking(update: Update, context: CallbackContext):
    logging.info("Entering cancel_booking")
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await get_vendors_type_list(update, context, True)
    return ConversationHandler.END

def get_list_services(services):
    keyboard = [[InlineKeyboardButton("–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data="back_to_vendors")]]
    message = "*–°–ø–∏—Å–æ–∫ —É—Å–ª—É–≥ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞:*\n\n"

    for service in services:
        keyboard.insert(0,
                        [InlineKeyboardButton(service['name'], callback_data=f"book_service_{service['service_id']}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    return message, reply_markup

def format_vendor_list_with_buttons(vendors):
    keyboard = []
    for vendor in vendors:
        keyboard.append([InlineKeyboardButton(vendor['name'], callback_data=f"select_vendor_{vendor['vendor_id']}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    message = "*–°–ø–∏—Å–æ–∫ –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤ —É—Å–ª—É–≥:*\n\n"
    for vendor in vendors:
        message += f"*–ù–∞–∑–≤–∞–Ω–∏–µ:* {vendor['name']}\n"
        message += f"*–ê–¥—Ä–µ—Å:* {vendor['address']}\n\n"
    return message, reply_markup

async def get_vendors_type_list(update: Update, context: CallbackContext, from_return=False):
    kb = [
        [InlineKeyboardButton("–†–µ—Å—Ç–æ—Ä–∞–Ω—ã", callback_data='Restaurant'),
         InlineKeyboardButton("–û—Ç–µ–ª–∏", callback_data='Hotel')],
        [InlineKeyboardButton("–Ø—Ö—Ç—ã", callback_data='Yacht'),
         InlineKeyboardButton("–¢—É—Ä—ã –∏ —ç–∫—Å–∫—É—Ä—Å–∏–∏", callback_data='TourOperator')]
    ]
    reply_markup = InlineKeyboardMarkup(kb)
    if not from_return:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é –≤–∞—Å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤:",
                                        reply_markup=reply_markup)
    else:
        await update.callback_query.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é –≤–∞—Å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤:",
                                                       reply_markup=reply_markup)

async def handle_predefined_questions(update: Update, context: CallbackContext, question_type: str) -> None:
    if question_type == "‚ÅâÔ∏è –û –Ω–∞—à–µ–º —Å–µ—Ä–≤–∏—Å–µ":
        await update.message.reply_text("–ó–¥–µ—Å—å –±—É–¥–µ—Ç —Ç–µ–∫—Å—Ç –æ —Å–µ—Ä–≤–∏—Å–µ...")
    elif question_type == "üìã –°–ø–∏—Å–æ–∫ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤":
        await get_vendors_type_list(update, context)
    elif question_type == "üçΩÔ∏è –ú–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è":
        await get_my_booking_list(update, context)
    elif question_type == "üí∏ –ú–æ–π –∫—ç—à–±–µ–∫":
        await update.message.reply_text("–ü—Ä–æ–≤–µ—Ä—è—é –≤–∞—à –±–∞–ª–∞–Ω—Å...")


async def get_my_booking_list(update, context):
    pass

async def web_app_data(update: Update, context: CallbackContext):
    logging.info(update.message.web_app_data.data)

async def error_handler(update: Update, context: CallbackContext) -> None:
    logging.error(msg="Exception while handling an update:", exc_info=context.error)


async def notify_vendor(context):
    booking_info = context.user_data
    booking_id = booking_info.get('booking_id')

    if not booking_id:
        logging.error("Missing booking_id in context user_data")
        return

    url = "http://127.0.0.1:8000/notify_vendor"
    payload = {
        "booking_id": booking_id
    }

    try:
        response = requests.post(url, json=payload)
        if response.status_code == 200:
            logging.info("Notification request sent successfully")
        else:
            logging.error(f"Failed to send notification request: {response.text}")
    except requests.exceptions.RequestException as e:
        logging.error(f"RequestException while sending notification request: {e}")

#     # Start a task to check if the booking is confirmed after a timeout
#     asyncio.create_task(reminder_task(context, booking_info))
#
# RETRY_INTERVAL = 15
#
# async def reminder_task(context, booking_info):
#     await asyncio.sleep(RETRY_INTERVAL)
#     # Check if booking is still not confirmed (This is a placeholder, implement your own check)
#     if not booking_info.get('confirmed', False):
#         message_text = (
#             f"Reminder: The booking request for date {booking_info['booking_date']} "
#             f"and time {booking_info['booking_time']} is still not confirmed.")
#         await context.bot.send_message(chat_id=338009078, text=message_text)
#

if __name__ == '__main__':
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.INFO
    )
    logger = logging.getLogger(__name__)

    # Create Telegram application
    application = ApplicationBuilder().token(TOKEN).build()

    # Command handlers
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('shop', shop))
    application.add_handler(CommandHandler('balance', get_balance))

    # Message handlers
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(r'^\d{4}-\d{2}-\d{2}$') & ~filters.Regex(r'^\d{2}:\d{2}$'),
                                           handle_message))
    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, web_app_data))
    application.add_handler(MessageHandler(filters.PHOTO, handle_photo))

    # Conversation handler
    conv_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(book_service, pattern='^book_service_')],
        states={
            DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND & filters.Regex(r'^\d{4}-\d{2}-\d{2}$'), received_date)],
            TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND & filters.Regex(r'^\d{2}:\d{2}$'), received_time)],
            CONFIRM: [CallbackQueryHandler(confirm_booking, pattern='^confirm$'),
                      CallbackQueryHandler(cancel_booking, pattern='^cancel$')]
        },
        fallbacks=[CommandHandler('cancel', cancel_booking)]
    )
    application.add_handler(conv_handler)

    # Callback query handler for other patterns
    application.add_handler(CallbackQueryHandler(handle_query, pattern='^(?!book_service_).*'))

    # Error handler
    application.add_error_handler(error_handler)

    # Start bot
    logging.info(f"Your bot is listening! Navigate to http://t.me/{BOT_USERNAME} to interact with it!")
    application.run_polling()